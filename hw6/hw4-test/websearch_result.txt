
FOUND: 0

Test query1.out passed!


FOUND: 3
FOUND: data/data1.txt
FOUND: data/data2.txt
FOUND: data/data3.txt

Test query2.out passed!


FOUND: 1
FOUND: data/data1.txt

Test query3.out passed!


FOUND: 1
FOUND: data/data5.txt

Test query4.out passed!


FOUND: 5
FOUND: data/data1.txt
FOUND: data/data2.txt
FOUND: data/data3.txt
FOUND: data/data4.txt
FOUND: data/data5.txt
FOUND: 1
FOUND: data/data4.txt
FOUND: 0
FOUND: 0
FOUND: 0

Test query5.out passed!


FOUND: 1
FOUND: data/data2.txt
FOUND: 5
FOUND: data/data1.txt
FOUND: data/data2.txt
FOUND: data/data3.txt
FOUND: data/data4.txt
FOUND: data/data5.txt
FOUND: 1
FOUND: data/data2.txt
FOUND: 3
FOUND: data/data1.txt
FOUND: data/data4.txt
FOUND: data/data5.txt
FOUND: 1
FOUND: data/data4.txt
FOUND: 3
FOUND: data/data1.txt
FOUND: data/data4.txt
FOUND: data/data5.txt

Test query6.out passed!


FOUND: 0

Test query7.out passed!


FOUND: 1
FOUND: data/data2.txt

Test query8.out passed!


FOUND: 1
FOUND: data/data5.txt

Test query9.out passed!


FOUND: 0

Test query10.out passed!


FOUND: 5
FOUND: data/data1.txt
FOUND: data/data2.txt
FOUND: data/data3.txt
FOUND: data/data4.txt
FOUND: data/data5.txt

Test query11.out passed!


FOUND: 5
FOUND: data/data1.txt
FOUND: data/data2.txt
FOUND: data/data3.txt
FOUND: data/data4.txt
FOUND: data/data5.txt

Test query12.out passed!


FOUND: 2
FOUND: data/data4.txt
FOUND: data/data5.txt

Test query13.out passed!


FOUND: 0

Test query14.out passed!


FOUND: data/data1.txt
FOUND: Yes, summer is the perfect time to relax and recharge. But, it’s also the perfect time to pick up a few new skills. Put that relaxed brain to good use! How accomplished would you feel if, when September rolls around, you could open up your resume and add another skill to it? Very, we’re guessing.
FOUND: Before you start stressing, know that we’re not asking you to sacrifice your summer nights to a droning professor, Instead, we’re suggesting devoting a few hours every week to advancing your career with an online class.
FOUND: To make the process easier for you, we did 2 things. One, we only chose classes you can complete in less than 10 weeks. Two, we hand-curated this list to ensure it’s only courses that are valuable and interesting. The best part? All of them are free.
FOUND: So, with no further ado, here are 43classes you can sign up for today. Yes that means 43 classes.
FOUND: data/data2.txt
FOUND: ####Harvard University’s Introduction to Computer Science
FOUND: As of Fall-2014, the on-campus version of this course was the largest at Harvard. You’ll learn how to think algorithmically, solve programming problems efficiently, and become familiar with a number of languages including CSS, HTML, and PHP. The class is free, but you can add a HarvardX Verified Certificate for $90.
FOUND: Level:Beginner
FOUND: Duration: 180-Hours/9-Lessons
FOUND: data/data3.txt
FOUND: ####Introduction to C++, MIT OpenCourseWare
FOUND: This four-week course provides a fast-paced introduction to C++ programming languages. You’ll learn the required background knowledge, including memory management, pointers, object-oriented programming, and how to find bugs when you inevitably use any of those incorrectly.
FOUND: Level: Beginner
FOUND: Duration: 16 Hours / 8 Lectures, 8 Labs
FOUND: data/data4.txt
FOUND: Last week, the Mars was under the international spotlight once more as NASA scientists announced that [liquid water may still be flowing on the surface of the red planet]. Also, the much-anticipated film adaptation of The Martian – a 2011 novel by American author Andy Weir – a science-driven story of human survival on Mars, hit the box office.  Mars was also the hot topic at a recent event held at the [National Space Centre in Leicester]. The guest of honour was Apollo 7 astronaut Walter Cunningham and throughout the hour-long Q&A, he emphasized the need to push the “next frontier” and send humans to Mars.
FOUND: Cunningham is not a man lacking in confidence or the experience of pushing boundaries. When asked if he ever felt the pressure of the astronaut selection or training process, he said “I thought I could fly anything, any time, anywhere. Was that true? I don’t know. But that’s how I felt.”
FOUND: From fighter pilot to NASA astronaut, Cunningham went on to crew the very first [1968]apollomission shortly after the Apollo 1 ground test ended tragically in fire. Apollo 7 flew for 11 days and orbited 163 times around the Earth, testing every part of the new command service module and completing the first US TV broadcast from space. Cunningham became the unofficial mission photographer when his right-seat window was one of the few that didn’t fog up due to a minor fault. Apollo 7 was critical in proving the capability of the capsule and, in many ways, its success paved the way for the Apollo 11 moon landing.
FOUND: “There wasn’t one of us the Apollo astronauts who wasn’t convinced we would be on Mars within our lifetime. That was just the rate things were going,” he said. However, Cunningham believes that we have since lost the drive to push boundaries in space and this, according to him, has come at a big cost to our society.
FOUND: data/data5.txt
FOUND: Countless technological breakthroughs made during the Apollo era have filtered into our lives today, from accurate satellite weather forecasts to the mobile phones in our pockets. Medical advances in osteoporosis treatment, digital mammography and food nutrition are all direct results of ongoing space research. The cost of the Apollo project was more than 100 billion US dollars in today’s currency. Nevertheless, it is currently [estimated] that for every dollar invested in the space programme, between $8 and $10 dollars’ worth of derivative benefits are added to the economy. This is the real argument in favour of sending humans to Mars, according to Cunningham.
FOUND: He also acknowledged that the basic science would be fascinating as there is much that we still do not know about Mars, and that humans are far more efficient and creative than [pre-programmed rovers]. But above all, he argued that our society owes it to itself and to future generations to keep pushing the frontier, in order to reap the unknown benefits in innovation and discovery.
FOUND: “There is an obligation by humanity to push the next frontier,” said Cunningham. “The world is as good as it is today because of this.” As Cunningham said at the beginning of the talk, “500 years from now, people will only remember only thing about the [20th century:] that it was the century when man first left Earth.”

Test query15.out passed!


FOUND: 0
FOUND: 0
FOUND: 0
FOUND: 3
FOUND: http://mars.nasa.gov/index.cfm
FOUND: http://www.spacecentre.co.uk/
FOUND: http://www.nasa.gov/mission_pages/apollo/index.html
FOUND: 3
FOUND: http://news.utexas.edu/2014/07/21/anniversary-shows-us-that-nasa-and-space-exploration-are-worth-their-costs
FOUND: http://www.jpl.nasa.gov/news/news.php?feature=1943
FOUND: https://en.wikipedia.org/wiki/20th_century

Test query16.out passed!


FOUND: 1
FOUND: data/data8.txt
FOUND: 0
FOUND: 1
FOUND: data/data8.txt
FOUND: 0
FOUND: 0
FOUND: 2
FOUND: data/data8.txt
FOUND: data/data9.txt
FOUND: 1
FOUND: data/data9.txt

Test query17.out passed!


FOUND: data/data6.txt
FOUND: ### Generic Build Instructions ###
FOUND: #### Setup ####
FOUND: To build Google Test and your tests that use it, you need to tell your
FOUND: build system where to find its headers and source files.  The exact
FOUND: way to do it depends on which build system you use, and is usually
FOUND: straightforward.
FOUND: #### Build ####
FOUND: Suppose you put Google Test in directory `${GTEST_DIR}`.  To build it,
FOUND: create a library build target to compile
FOUND: ${GTEST_DIR}/src/gtest-all.cc
FOUND: with `${GTEST_DIR}/include` in the system header search path and `${GTEST_DIR}`
FOUND: in the normal header search path.  Assuming a Linux-like system and gcc,
FOUND: something like the following will do:
FOUND: g++ -isystem ${GTEST_DIR}/include -I${GTEST_DIR} \
FOUND: -pthread -c ${GTEST_DIR}/src/gtest-all.cc
FOUND: ar -rv libgtest.a gtest-all.o
FOUND: Next, you should compile your test source file with
FOUND: `${GTEST_DIR}/include` in the system header search path, and link it
FOUND: with gtest and any other necessary libraries:
FOUND: g++ -isystem ${GTEST_DIR}/include -pthread path/to/your_test.cc libgtest.a \
FOUND: -o your_test
FOUND: As an example, the make/ directory contains a Makefile that you can
FOUND: use to build Google Test on systems where GNU make is available.  It doesn't try to build Google
FOUND: Test's own tests.  Instead, it just builds the Google Test library and
FOUND: a sample test.  You can use it as a starting point for your own build
FOUND: script.
FOUND: If the default settings are correct for your environment, the
FOUND: following commands should succeed:
FOUND: cd ${GTEST_DIR}/make
FOUND: make
FOUND: ./sample1_unittest
FOUND: If you see errors, try to tweak the contents of `make/Makefile` to make
FOUND: them go away.  There are instructions in `make/Makefile` on how to do
FOUND: it.
FOUND: ### Using CMake ###
FOUND: Google Test comes with a CMake build script
FOUND: [CMakeLists.txt] that can be used on a wide range of platforms. If you don't have CMake installed already, you can
FOUND: download it for free from <http://www.cmake.org/>.
FOUND: CMake works by generating native makefiles or build projects that can
FOUND: be used in the compiler environment of your choice.  You can either
FOUND: build Google Test as a standalone project or it can be incorporated
FOUND: into an existing CMake build for another project.
FOUND: #### Standalone CMake Project ####
FOUND: When building Google Test as a standalone project, the typical
FOUND: workflow starts with:
FOUND: mkdir mybuild       # Create a directory to hold the build output.
FOUND: cd mybuild
FOUND: cmake ${GTEST_DIR}  # Generate native build scripts.
FOUND: If you want to build Google Test's samples, you should replace the
FOUND: last command with
FOUND: cmake -Dgtest_build_samples=ON ${GTEST_DIR}
FOUND: If you are on a \*nix system, you should now see a Makefile in the
FOUND: current directory.  Just type 'make' to build gtest.
FOUND: If you use Windows and have Visual Studio installed, a `gtest.sln` file
FOUND: and several `.vcproj` files will be created.  You can then build them
FOUND: using Visual Studio.
FOUND: On Mac OS X with Xcode installed, a `.xcodeproj` file will be generated.
FOUND: #### Incorporating Into An Existing CMake Project ####
FOUND: If you want to use gtest in a project which already uses CMake, then a
FOUND: more robust and flexible approach is to build gtest as part of that
FOUND: project directly. This is done by making the GoogleTest source code
FOUND: available to the main build and adding it using CMake's
FOUND: `add_subdirectory` command. This has the significant advantage that
FOUND: the same compiler and linker settings are used between gtest and the
FOUND: rest of your project, so issues associated with using incompatible
FOUND: libraries, etc. are avoided. This is particularly
FOUND: useful on Windows. Making GoogleTest's source code available to the
FOUND: main build can be done a few different ways:
FOUND: * Download the GoogleTest source code manually and place it at a
FOUND: known location. This is the least flexible approach and can make
FOUND: it more difficult to use with continuous integration systems, etc.
FOUND: * Embed the GoogleTest source code as a direct copy in the main
FOUND: project's source tree. This is often the simplest approach, but is
FOUND: also the hardest to keep up to date. Some organizations may not
FOUND: permit this method.
FOUND: * Add GoogleTest as a git submodule or equivalent. This may not
FOUND: always be possible or appropriate. Git submodules, for example,
FOUND: have their own set of advantages and drawbacks.
FOUND: * Use CMake to download GoogleTest as part of the build's configure
FOUND: step. This is just a little more complex, but doesn't have the
FOUND: limitations of the other methods.
FOUND: The last of the above methods is implemented with a small piece
FOUND: of CMake code in a separate file which
FOUND: is copied to the build area and then invoked as a sub-build
FOUND: _during the CMake stage_. That directory is then pulled into the
FOUND: main build with `add_subdirectory`. For example:
FOUND: New file `CMakeLists.txt.in`:
FOUND: cmake_minimum_required
FOUND: project
FOUND: include
FOUND: ExternalProject_Addgoogletest
FOUND: GIT_REPOSITORY    https://github.com/google/googletest.git
FOUND: GIT_TAG           master
FOUND: SOURCE_DIR        "${CMAKE_BINARY_DIR}/googletest-src"
FOUND: BINARY_DIR        "${CMAKE_BINARY_DIR}/googletest-build"
FOUND: CONFIGURE_COMMAND ""
FOUND: BUILD_COMMAND     ""
FOUND: INSTALL_COMMAND   ""
FOUND: TEST_COMMAND      ""
FOUND: Existing build's `CMakeLists.txt`:
FOUND: # Download and unpack googletest at configure time
FOUND: configure_file
FOUND: execute_process COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" .
FOUND: RESULT_VARIABLE result
FOUND: WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/googletest-download
FOUND: if
FOUND: message
FOUND: endif
FOUND: execute_processCOMMAND ${CMAKE_COMMAND} --build .
FOUND: RESULT_VARIABLE result
FOUND: WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/googletest-download
FOUND: if
FOUND: message
FOUND: endif
FOUND: # Prevent overriding the parent project's compiler/linker
FOUND: # settings on Windows
FOUND: set
FOUND: # Add googletest directly to our build. This defines
FOUND: # the gtest and gtest_main targets.
FOUND: add_subdirectory{CMAKE_BINARY_DIR}/googletest-src
FOUND: ${CMAKE_BINARY_DIR}/googletest-build
FOUND: EXCLUDE_FROM_ALL
FOUND: # The gtest/gtest_main targets carry header search path
FOUND: # dependencies automatically when using CMake 2.8.11 or
FOUND: # later. Otherwise we have to add them here ourselves.
FOUND: if
FOUND: include_directories
FOUND: endif
FOUND: # Now simply link against gtest or gtest_main as needed. Eg
FOUND: add_executable
FOUND: target_link_libraries
FOUND: add_test
FOUND: Note that this approach requires CMake 2.8.2 or later due to
FOUND: its use of the `ExternalProject_Add` command. The above
FOUND: technique is discussed in more detail in
FOUND: [this separate article]
FOUND: which also contains a link to a fully generalized implementation
FOUND: of the technique.
FOUND: ##### Visual Studio Dynamic vs Static Runtimes #####
FOUND: By default, new Visual Studio projects link the C runtimes dynamically
FOUND: but Google Test links them statically.
FOUND: This will generate an error that looks something like the following:
FOUND: gtest.lib : error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in main.obj
FOUND: Google Test already has a CMake option for this: `gtest_force_shared_crt`
FOUND: Enabling this option will make gtest link the runtimes dynamically too,
FOUND: and match the project in which it is included.
FOUND: ### Legacy Build Scripts ###
FOUND: Before settling on CMake, we have been providing hand-maintained build
FOUND: projects/scripts for Visual Studio, Xcode, and Autotools.  While we
FOUND: continue to provide them for convenience, they are not actively
FOUND: maintained any more.  We highly recommend that you follow the
FOUND: instructions in the above sections to integrate Google Test
FOUND: with your existing build system.
FOUND: If you still need to use the legacy build scripts, here's how:
FOUND: The msvc\ folder contains two solutions with Visual C++ projects.
FOUND: Open the `gtest.sln` or `gtest-md.sln` file using Visual Studio, and you
FOUND: are ready to build Google Test the same way you build any Visual
FOUND: Studio project.  Files that have names ending with -md use DLL
FOUND: versions of Microsoft runtime libraries.  Files without that suffix use static versions of the runtime
FOUND: libraries .  Please note that one must use
FOUND: the same option to compile both gtest and the test code.  If you use
FOUND: Visual Studio 2005 or above, we recommend the -md version as /MD is
FOUND: the default for new projects in these versions of Visual Studio.
FOUND: On Mac OS X, open the `gtest.xcodeproj` in the `xcode/` folder using
FOUND: Xcode.  Build the "gtest" target.  The universal binary framework will
FOUND: end up in your selected build directory.
FOUND: Alternatively, at the command line, enter:
FOUND: xcodebuild
FOUND: This will build the "Release" configuration of gtest.framework in your
FOUND: default build location.  See the "xcodebuild" man page for more
FOUND: information about building different configurations and building in
FOUND: different locations.
FOUND: If you wish to use the Google Test Xcode project with Xcode 4.x and
FOUND: above, you need to either:
FOUND: * update the SDK configuration options in xcode/Config/General.xconfig.
FOUND: Comment options `SDKROOT`, `MACOS_DEPLOYMENT_TARGET`, and `GCC_VERSION`. If
FOUND: you choose this route you lose the ability to target earlier versions
FOUND: of MacOS X.
FOUND: * Install an SDK for an earlier version. This doesn't appear to be
FOUND: supported by Apple, but has been reported to work
FOUND: .
FOUND: ### Tweaking Google Test ###
FOUND: Google Test can be used in diverse environments.  The default
FOUND: configuration may not work  out of the box in
FOUND: some environments.  However, you can easily tweak Google Test by
FOUND: defining control macros on the compiler command line.  Generally,
FOUND: these macros are named like `GTEST_XYZ` and you define them to either 1
FOUND: or 0 to enable or disable a certain feature.
FOUND: We list the most frequently used macros below.  For a complete list,
FOUND: see file [include/gtest/internal/gtest-port.h].
FOUND: ### Choosing a TR1 Tuple Library ###
FOUND: Some Google Test features require the C++ Technical Report 1
FOUND: tuple library, which is not yet available with all compilers.  The
FOUND: good news is that Google Test implements a subset of TR1 tuple that's
FOUND: enough for its own need, and will automatically use this when the
FOUND: compiler doesn't provide TR1 tuple.
FOUND: Usually you don't need to care about which tuple library Google Test
FOUND: uses.  However, if your project already uses TR1 tuple, you need to
FOUND: tell Google Test to use the same TR1 tuple library the rest of your
FOUND: project uses, or the two tuple implementations will clash.  To do
FOUND: that, add
FOUND: -DGTEST_USE_OWN_TR1_TUPLE=0
FOUND: to the compiler flags while compiling Google Test and your tests.  If
FOUND: you want to force Google Test to use its own tuple library, just add
FOUND: -DGTEST_USE_OWN_TR1_TUPLE=1
FOUND: to the compiler flags instead.
FOUND: If you don't want Google Test to use tuple at all, add
FOUND: -DGTEST_HAS_TR1_TUPLE=0
FOUND: and all features using tuple will be disabled.
FOUND: ### Multi-threaded Tests ###
FOUND: Google Test is thread-safe where the pthread library is available.
FOUND: After `#include "gtest/gtest.h"`, you can check the `GTEST_IS_THREADSAFE`
FOUND: macro to see whether this is the case.
FOUND: If Google Test doesn't correctly detect whether pthread is available
FOUND: in your environment, you can force it with
FOUND: -DGTEST_HAS_PTHREAD=1
FOUND: or
FOUND: -DGTEST_HAS_PTHREAD=0
FOUND: When Google Test uses pthread, you may need to add flags to your
FOUND: compiler and/or linker to select the pthread library, or you'll get
FOUND: link errors.  If you use the CMake script or the deprecated Autotools
FOUND: script, this is taken care of for you.  If you use your own build
FOUND: script, you'll need to read your compiler and linker's manual to
FOUND: figure out what flags to add.
FOUND: ### As a Shared Library  ###
FOUND: Google Test is compact, so most users can build and link it as a
FOUND: static library for the simplicity.  You can choose to use Google Test
FOUND: as a shared library  if you prefer.
FOUND: To compile *gtest* as a shared library, add
FOUND: -DGTEST_CREATE_SHARED_LIBRARY=1
FOUND: to the compiler flags.  You'll also need to tell the linker to produce
FOUND: a shared library instead - consult your linker's manual for how to do
FOUND: it.
FOUND: To compile your *tests* that use the gtest shared library, add
FOUND: -DGTEST_LINKED_AS_SHARED_LIBRARY=1
FOUND: to the compiler flags.
FOUND: Note: while the above steps aren't technically necessary today when
FOUND: using some compilers , they may become necessary in the
FOUND: future, if we decide to improve the speed of loading the library.  Therefore you are
FOUND: recommended to always add the above flags when using Google Test as a
FOUND: shared library.  Otherwise a future release of Google Test may break
FOUND: your build script.
FOUND: ### Avoiding Macro Name Clashes ###
FOUND: In C++, macros don't obey namespaces.  Therefore two libraries that
FOUND: both define a macro of the same name will clash if you `#include` both
FOUND: definitions.  In case a Google Test macro clashes with another
FOUND: library, you can force Google Test to rename its macro to avoid the
FOUND: conflict.
FOUND: Specifically, if both Google Test and some other code define macro
FOUND: FOO, you can add
FOUND: -DGTEST_DONT_DEFINE_FOO=1
FOUND: to the compiler flags to tell Google Test to change the macro's name
FOUND: from `FOO` to `GTEST_FOO`.  Currently `FOO` can be `FAIL`, `SUCCEED`,
FOUND: or `TEST`.  For example, with `-DGTEST_DONT_DEFINE_TEST=1`, you'll
FOUND: need to write
FOUND: GTEST_TEST { ... }
FOUND: instead of
FOUND: TEST { ... }
FOUND: in order to define a test.
FOUND: data/data7.txt
FOUND: Markdown: Syntax
FOUND: ================
FOUND: <ul id="ProjectSubmenu">
FOUND: <li><a href="/projects/markdown/" title="Markdown Project Page">Main</a></li>
FOUND: <li><a href="/projects/markdown/basics" title="Markdown Basics">Basics</a></li>
FOUND: <li><a class="selected" title="Markdown Syntax Documentation">Syntax</a></li>
FOUND: <li><a href="/projects/markdown/license" title="Pricing and License Information">License</a></li>
FOUND: <li><a href="/projects/markdown/dingus" title="Online Markdown Web Form">Dingus</a></li>
FOUND: </ul>
FOUND: *   [Overview]
FOUND: *   [Philosophy]
FOUND: *   [Inline HTML]
FOUND: *   [Automatic Escaping for Special Characters]
FOUND: *   [Block Elements]
FOUND: *   [Paragraphs and Line Breaks]
FOUND: *   [Headers]
FOUND: *   [Blockquotes]
FOUND: *   [Lists]
FOUND: *   [Code Blocks]
FOUND: *   [Horizontal Rules]
FOUND: *   [Span Elements]
FOUND: *   [Links]
FOUND: *   [Emphasis]
FOUND: *   [Code]
FOUND: *   [Images]
FOUND: *   [Miscellaneous]
FOUND: *   [Backslash Escapes]
FOUND: *   [Automatic Links]
FOUND: **Note:** This document is itself written using Markdown; you
FOUND: can <see the source for it by adding '.text' to the URL><src>.
FOUND: <src>: /projects/markdown/syntax.text
FOUND: * * *
FOUND: <h2 id="overview">Overview</h2>
FOUND: <h3 id="philosophy">Philosophy</h3>
FOUND: Markdown is intended to be as easy-to-read and easy-to-write as is feasible.
FOUND: Readability, however, is emphasized above all else. A Markdown-formatted
FOUND: document should be publishable as-is, as plain text, without looking
FOUND: like it's been marked up with tags or formatting instructions. While
FOUND: Markdown's syntax has been influenced by several existing text-to-HTML
FOUND: filters -- including <Setext>  <1>, <atx> <2>, <Textile> <3>, <reStructuredText> <4>,
FOUND: <Grutatext> <5>, and <EtText> <6> -- the single biggest source of
FOUND: inspiration for Markdown's syntax is the format of plain text email.
FOUND: <1>: http://docutils.sourceforge.net/mirror/setext.html
FOUND: <2>: http://www.aaronsw.com/2002/atx/
FOUND: <3>: http://textism.com/tools/textile/
FOUND: <4>: http://docutils.sourceforge.net/rst.html
FOUND: <5>: http://www.triptico.com/software/grutatxt.html
FOUND: <6>: http://ettext.taint.org/doc/
FOUND: To this end, Markdown's syntax is comprised entirely of punctuation
FOUND: characters, which punctuation characters have been carefully chosen so
FOUND: as to look like what they mean. E.g., asterisks around a word actually
FOUND: look like \*emphasis\*. Markdown lists look like, well, lists. Even
FOUND: blockquotes look like quoted passages of text, assuming you've ever
FOUND: used email.
FOUND: <h3 id="html">Inline HTML</h3>
FOUND: Markdown's syntax is intended for one purpose: to be used as a
FOUND: format for *writing* for the web.
FOUND: Markdown is not a replacement for HTML, or even close to it. Its
FOUND: syntax is very small, corresponding only to a very small subset of
FOUND: HTML tags. The idea is *not* to create a syntax that makes it easier
FOUND: to insert HTML tags. In my opinion, HTML tags are already easy to
FOUND: insert. The idea for Markdown is to make it easy to read, write, and
FOUND: edit prose. HTML is a *publishing* format; Markdown is a *writing*
FOUND: format. Thus, Markdown's formatting syntax only addresses issues that
FOUND: can be conveyed in plain text.
FOUND: For any markup that is not covered by Markdown's syntax, you simply
FOUND: use HTML itself. There's no need to preface it or delimit it to
FOUND: indicate that you're switching from Markdown to HTML; you just use
FOUND: the tags.
FOUND: The only restrictions are that block-level HTML elements -- e.g. `<div>`,
FOUND: `<table>`, `<pre>`, `<p>`, etc. -- must be separated from surrounding
FOUND: content by blank lines, and the start and end tags of the block should
FOUND: not be indented with tabs or spaces. Markdown is smart enough not
FOUND: to add extra `<p>` tags around HTML block-level tags.
FOUND: For example, to add an HTML table to a Markdown article:
FOUND: This is a regular paragraph.
FOUND: <table>
FOUND: <tr>
FOUND: <td>Foo</td>
FOUND: </tr>
FOUND: </table>
FOUND: This is another regular paragraph.
FOUND: Note that Markdown formatting syntax is not processed within block-level
FOUND: HTML tags. E.g., you can't use Markdown-style `*emphasis*` inside an
FOUND: HTML block.
FOUND: Span-level HTML tags -- e.g. `<span>`, `<cite>`, or `<del>` -- can be
FOUND: used anywhere in a Markdown paragraph, list item, or header. If you
FOUND: want, you can even use HTML tags instead of Markdown formatting; e.g. if
FOUND: you'd prefer to use HTML `<a>` or `<img>` tags instead of Markdown's
FOUND: link or image syntax, go right ahead.
FOUND: Unlike block-level HTML tags, Markdown syntax *is* processed within
FOUND: span-level tags.
FOUND: <h3 id="autoescape">Automatic Escaping for Special Characters</h3>
FOUND: In HTML, there are two characters that demand special treatment: `<`
FOUND: and `&`. Left angle brackets are used to start tags; ampersands are
FOUND: used to denote HTML entities. If you want to use them as literal
FOUND: characters, you must escape them as entities, e.g. `&lt;`, and
FOUND: `&amp;`.
FOUND: Ampersands in particular are bedeviling for web writers. If you want to
FOUND: write about 'AT&T', you need to write '`AT&amp;T`'. You even need to
FOUND: escape ampersands within URLs. Thus, if you want to link to:
FOUND: http://images.google.com/images?num=30&q=larry+bird
FOUND: you need to encode the URL as:
FOUND: http://images.google.com/images?num=30&amp;q=larry+bird
FOUND: in your anchor tag `href` attribute. Needless to say, this is easy to
FOUND: forget, and is probably the single most common source of HTML validation
FOUND: errors in otherwise well-marked-up web sites.
FOUND: Markdown allows you to use these characters naturally, taking care of
FOUND: all the necessary escaping for you. If you use an ampersand as part of
FOUND: an HTML entity, it remains unchanged; otherwise it will be translated
FOUND: into `&amp;`.
FOUND: So, if you want to include a copyright symbol in your article, you can write:
FOUND: &copy;
FOUND: and Markdown will leave it alone. But if you write:
FOUND: AT&T
FOUND: Markdown will translate it to:
FOUND: AT&amp;T
FOUND: Similarly, because Markdown supports [inline HTML], if you use
FOUND: angle brackets as delimiters for HTML tags, Markdown will treat them as
FOUND: such. But if you write:
FOUND: 4 < 5
FOUND: Markdown will translate it to:
FOUND: 4 &lt; 5
FOUND: However, inside Markdown code spans and blocks, angle brackets and
FOUND: ampersands are *always* encoded automatically. This makes it easy to use
FOUND: Markdown to write about HTML code.
FOUND: * * *
FOUND: <h2 id="block">Block Elements</h2>
FOUND: <h3 id="p">Paragraphs and Line Breaks</h3>
FOUND: A paragraph is simply one or more consecutive lines of text, separated
FOUND: by one or more blank lines. Normal paragraphs should not be indented with spaces or tabs.
FOUND: The implication of the "one or more consecutive lines of text" rule is
FOUND: that Markdown supports "hard-wrapped" text paragraphs. This differs
FOUND: significantly from most other text-to-HTML formatters which translate every line break
FOUND: character in a paragraph into a `<br />` tag.
FOUND: When you *do* want to insert a `<br />` break tag using Markdown, you
FOUND: end a line with two or more spaces, then type return.
FOUND: Yes, this takes a tad more effort to create a `<br />`, but a simplistic
FOUND: "every line break is a `<br />`" rule wouldn't work for Markdown.
FOUND: Markdown's email-style <blockquoting><bq> and multi-paragraph <list items><l>
FOUND: work best -- and look better -- when you format them with hard breaks.
FOUND: <bq>: #blockquote
FOUND: <l>:  #list
FOUND: <h3 id="header">Headers</h3>
FOUND: Markdown supports two styles of headers, <Setext> <1> and <atx> <2>.
FOUND: Setext-style headers are "underlined" using equal signs and dashes. For example:
FOUND: This is an H1
FOUND: =============
FOUND: This is an H2
FOUND: -------------
FOUND: Any number of underlining `=`'s or `-`'s will work.
FOUND: Atx-style headers use 1-6 hash characters at the start of the line,
FOUND: corresponding to header levels 1-6. For example:
FOUND: # This is an H1
FOUND: ## This is an H2
FOUND: ###### This is an H6
FOUND: Optionally, you may "close" atx-style headers. This is purely
FOUND: cosmetic -- you can use this if you think it looks better. The
FOUND: closing hashes don't even need to match the number of hashes
FOUND: used to open the header. :
FOUND: # This is an H1 #
FOUND: ## This is an H2 ##
FOUND: ### This is an H3 ######
FOUND: <h3 id="blockquote">Blockquotes</h3>
FOUND: Markdown uses email-style `>` characters for blockquoting. If you're
FOUND: familiar with quoting passages of text in an email message, then you
FOUND: know how to create a blockquote in Markdown. It looks best if you hard
FOUND: wrap the text and put a `>` before every line:
FOUND: > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
FOUND: > consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
FOUND: > Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
FOUND: >
FOUND: > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
FOUND: > id sem consectetuer libero luctus adipiscing.
FOUND: Markdown allows you to be lazy and only put the `>` before the first
FOUND: line of a hard-wrapped paragraph:
FOUND: > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
FOUND: consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
FOUND: Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
FOUND: > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
FOUND: id sem consectetuer libero luctus adipiscing.
FOUND: Blockquotes can be nested by
FOUND: adding additional levels of `>`:
FOUND: > This is the first level of quoting.
FOUND: >
FOUND: > > This is nested blockquote.
FOUND: >
FOUND: > Back to the first level.
FOUND: Blockquotes can contain other Markdown elements, including headers, lists,
FOUND: and code blocks:
FOUND: > ## This is a header.
FOUND: >
FOUND: > 1.   This is the first list item.
FOUND: > 2.   This is the second list item.
FOUND: >
FOUND: > Here's some example code:
FOUND: >
FOUND: >     return shell_exe;
FOUND: Any decent text editor should make email-style quoting easy. For
FOUND: example, with BBEdit, you can make a selection and choose Increase
FOUND: Quote Level from the Text menu.
FOUND: <h3 id="list">Lists</h3>
FOUND: Markdown supports ordered and unordered lists.
FOUND: Unordered lists use asterisks, pluses, and hyphens -- interchangably
FOUND: -- as list markers:
FOUND: *   Red
FOUND: *   Green
FOUND: *   Blue
FOUND: is equivalent to:
FOUND: +   Red
FOUND: +   Green
FOUND: +   Blue
FOUND: and:
FOUND: -   Red
FOUND: -   Green
FOUND: -   Blue
FOUND: Ordered lists use numbers followed by periods:
FOUND: 1.  Bird
FOUND: 2.  McHale
FOUND: 3.  Parish
FOUND: It's important to note that the actual numbers you use to mark the
FOUND: list have no effect on the HTML output Markdown produces. The HTML
FOUND: Markdown produces from the above list is:
FOUND: <ol>
FOUND: <li>Bird</li>
FOUND: <li>McHale</li>
FOUND: <li>Parish</li>
FOUND: </ol>
FOUND: If you instead wrote the list in Markdown like this:
FOUND: 1.  Bird
FOUND: 1.  McHale
FOUND: 1.  Parish
FOUND: or even:
FOUND: 3. Bird
FOUND: 1. McHale
FOUND: 8. Parish
FOUND: you'd get the exact same HTML output. The point is, if you want to,
FOUND: you can use ordinal numbers in your ordered Markdown lists, so that
FOUND: the numbers in your source match the numbers in your published HTML.
FOUND: But if you want to be lazy, you don't have to.
FOUND: If you do use lazy list numbering, however, you should still start the
FOUND: list with the number 1. At some point in the future, Markdown may support
FOUND: starting ordered lists at an arbitrary number.
FOUND: List markers typically start at the left margin, but may be indented by
FOUND: up to three spaces. List markers must be followed by one or more spaces
FOUND: or a tab.
FOUND: To make lists look nice, you can wrap items with hanging indents:
FOUND: *   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
FOUND: Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
FOUND: viverra nec, fringilla in, laoreet vitae, risus.
FOUND: *   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
FOUND: Suspendisse id sem consectetuer libero luctus adipiscing.
FOUND: But if you want to be lazy, you don't have to:
FOUND: *   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
FOUND: Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
FOUND: viverra nec, fringilla in, laoreet vitae, risus.
FOUND: *   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
FOUND: Suspendisse id sem consectetuer libero luctus adipiscing.
FOUND: If list items are separated by blank lines, Markdown will wrap the
FOUND: items in `<p>` tags in the HTML output. For example, this input:
FOUND: *   Bird
FOUND: *   Magic
FOUND: will turn into:
FOUND: <ul>
FOUND: <li>Bird</li>
FOUND: <li>Magic</li>
FOUND: </ul>
FOUND: But this:
FOUND: *   Bird
FOUND: *   Magic
FOUND: will turn into:
FOUND: <ul>
FOUND: <li><p>Bird</p></li>
FOUND: <li><p>Magic</p></li>
FOUND: </ul>
FOUND: List items may consist of multiple paragraphs. Each subsequent
FOUND: paragraph in a list item must be indented by either 4 spaces
FOUND: or one tab:
FOUND: 1.  This is a list item with two paragraphs. Lorem ipsum dolor
FOUND: sit amet, consectetuer adipiscing elit. Aliquam hendrerit
FOUND: mi posuere lectus.
FOUND: Vestibulum enim wisi, viverra nec, fringilla in, laoreet
FOUND: vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
FOUND: sit amet velit.
FOUND: 2.  Suspendisse id sem consectetuer libero luctus adipiscing.
FOUND: It looks nice if you indent every line of the subsequent
FOUND: paragraphs, but here again, Markdown will allow you to be
FOUND: lazy:
FOUND: *   This is a list item with two paragraphs.
FOUND: This is the second paragraph in the list item. You're
FOUND: only required to indent the first line. Lorem ipsum dolor
FOUND: sit amet, consectetuer adipiscing elit.
FOUND: *   Another item in the same list.
FOUND: To put a blockquote within a list item, the blockquote's `>`
FOUND: delimiters need to be indented:
FOUND: *   A list item with a blockquote:
FOUND: > This is a blockquote
FOUND: > inside a list item.
FOUND: To put a code block within a list item, the code block needs
FOUND: to be indented *twice* -- 8 spaces or two tabs:
FOUND: *   A list item with a code block:
FOUND: <code goes here>
FOUND: It's worth noting that it's possible to trigger an ordered list by
FOUND: accident, by writing something like this:
FOUND: 1986. What a great season.
FOUND: In other words, a *number-period-space* sequence at the beginning of a
FOUND: line. To avoid this, you can backslash-escape the period:
FOUND: 1986\. What a great season.
FOUND: <h3 id="precode">Code Blocks</h3>
FOUND: Pre-formatted code blocks are used for writing about programming or
FOUND: markup source code. Rather than forming normal paragraphs, the lines
FOUND: of a code block are interpreted literally. Markdown wraps a code block
FOUND: in both `<pre>` and `<code>` tags.
FOUND: To produce a code block in Markdown, simply indent every line of the
FOUND: block by at least 4 spaces or 1 tab. For example, given this input:
FOUND: This is a normal paragraph:
FOUND: This is a code block.
FOUND: Markdown will generate:
FOUND: <p>This is a normal paragraph:</p>
FOUND: <pre><code>This is a code block.
FOUND: </code></pre>
FOUND: One level of indentation -- 4 spaces or 1 tab -- is removed from each
FOUND: line of the code block. For example, this:
FOUND: Here is an example of AppleScript:
FOUND: tell application "Foo"
FOUND: beep
FOUND: end tell
FOUND: will turn into:
FOUND: <p>Here is an example of AppleScript:</p>
FOUND: <pre><code>tell application "Foo"
FOUND: beep
FOUND: end tell
FOUND: </code></pre>
FOUND: A code block continues until it reaches a line that is not indented.
FOUND: Within a code block, ampersands and angle brackets
FOUND: are automatically converted into HTML entities. This makes it very
FOUND: easy to include example HTML source code using Markdown -- just paste
FOUND: it and indent it, and Markdown will handle the hassle of encoding the
FOUND: ampersands and angle brackets. For example, this:
FOUND: <div class="footer">
FOUND: &copy; 2004 Foo Corporation
FOUND: </div>
FOUND: will turn into:
FOUND: <pre><code>&lt;div class="footer"&gt;
FOUND: &amp;copy; 2004 Foo Corporation
FOUND: &lt;/div&gt;
FOUND: </code></pre>
FOUND: Regular Markdown syntax is not processed within code blocks. E.g.,
FOUND: asterisks are just literal asterisks within a code block. This means
FOUND: it's also easy to use Markdown to write about Markdown's own syntax.
FOUND: <h3 id="hr">Horizontal Rules</h3>
FOUND: You can produce a horizontal rule tag by placing three or
FOUND: more hyphens, asterisks, or underscores on a line by themselves. If you
FOUND: wish, you may use spaces between the hyphens or asterisks. Each of the
FOUND: following lines will produce a horizontal rule:
FOUND: * * *
FOUND: ***
FOUND: *****
FOUND: - - -
FOUND: ---------------------------------------
FOUND: * * *
FOUND: <h2 id="span">Span Elements</h2>
FOUND: <h3 id="link">Links</h3>
FOUND: Markdown supports two style of links: *inline* and *reference*.
FOUND: In both styles, the link text is delimited by <square brackets>.
FOUND: To create an inline link, use a set of regular parentheses immediately
FOUND: after the link text's closing square bracket. Inside the parentheses,
FOUND: put the URL where you want the link to point, along with an *optional*
FOUND: title for the link, surrounded in quotes. For example:
FOUND: This is [an example] inline link.
FOUND: [This link] has no title attribute.
FOUND: Will produce:
FOUND: <p>This is <a href="http://example.com/" title="Title">
FOUND: an example</a> inline link.</p>
FOUND: <p><a href="http://example.net/">This link</a> has no
FOUND: title attribute.</p>
FOUND: If you're referring to a local resource on the same server, you can
FOUND: use relative paths:
FOUND: See my [About] page for details.
FOUND: Reference-style links use a second set of square brackets, inside
FOUND: which you place a label of your choosing to identify the link:
FOUND: This is <an example><id> reference-style link.
FOUND: You can optionally use a space to separate the sets of brackets:
FOUND: This is <an example> <id> reference-style link.
FOUND: Then, anywhere in the document, you define your link label like this,
FOUND: on a line by itself:
FOUND: <id>: http://example.com/  "Optional Title Here"
FOUND: That is:
FOUND: *   Square brackets containing the link identifier ;
FOUND: *   followed by a colon;
FOUND: *   followed by one or more spaces;
FOUND: *   followed by the URL for the link;
FOUND: *   optionally followed by a title attribute for the link, enclosed
FOUND: in double or single quotes, or enclosed in parentheses.
FOUND: The following three link definitions are equivalent:
FOUND: <foo>: http://example.com/  "Optional Title Here"
FOUND: <foo>: http://example.com/  'Optional Title Here'
FOUND: <foo>: http://example.com/
FOUND: **Note:** There is a known bug in Markdown.pl 1.0.1 which prevents
FOUND: single quotes from being used to delimit link titles.
FOUND: The link URL may, optionally, be surrounded by angle brackets:
FOUND: <id>: <http://example.com/>  "Optional Title Here"
FOUND: You can put the title attribute on the next line and use extra spaces
FOUND: or tabs for padding, which tends to look better with longer URLs:
FOUND: <id>: http://example.com/longish/path/to/resource/here
FOUND: "Optional Title Here"
FOUND: Link definitions are only used for creating links during Markdown
FOUND: processing, and are stripped from your document in the HTML output.
FOUND: Link definition names may consist of letters, numbers, spaces, and
FOUND: punctuation -- but they are *not* case sensitive. E.g. these two
FOUND: links:
FOUND: <link text><a>
FOUND: <link text><A>
FOUND: are equivalent.
FOUND: The *implicit link name* shortcut allows you to omit the name of the
FOUND: link, in which case the link text itself is used as the name.
FOUND: Just use an empty set of square brackets -- e.g., to link the word
FOUND: "Google" to the google.com web site, you could simply write:
FOUND: <Google><>
FOUND: And then define the link:
FOUND: <Google>: http://google.com/
FOUND: Because link names may contain spaces, this shortcut even works for
FOUND: multiple words in the link text:
FOUND: Visit <Daring Fireball><> for more information.
FOUND: And then define the link:
FOUND: <Daring Fireball>: http://daringfireball.net/
FOUND: Link definitions can be placed anywhere in your Markdown document. I
FOUND: tend to put them immediately after each paragraph in which they're
FOUND: used, but if you want, you can put them all at the end of your
FOUND: document, sort of like footnotes.
FOUND: Here's an example of reference links in action:
FOUND: <1>: http://google.com/        "Google"
FOUND: <2>: http://search.yahoo.com/  "Yahoo Search"
FOUND: <3>: http://search.msn.com/    "MSN Search"
FOUND: Using the implicit link name shortcut, you could instead write:
FOUND: [google]        "Google"
FOUND: [yahoo]  "Yahoo Search"
FOUND: [msn]    "MSN Search"
FOUND: Both of the above examples will produce the following HTML output:
FOUND: <p>I get 10 times more traffic from <a href="http://google.com/"
FOUND: title="Google">Google</a> than from
FOUND: <a href="http://search.yahoo.com/" title="Yahoo Search">Yahoo</a>
FOUND: or <a href="http://search.msn.com/" title="MSN Search">MSN</a>.</p>
FOUND: For comparison, here is the same paragraph written using
FOUND: Markdown's inline link style:
FOUND: I get 10 times more traffic from [Google]
FOUND: than from [Yahoo] or
FOUND: [MSN].
FOUND: The point of reference-style links is not that they're easier to
FOUND: write. The point is that with reference-style links, your document
FOUND: source is vastly more readable. Compare the above examples: using
FOUND: reference-style links, the paragraph itself is only 81 characters
FOUND: long; with inline-style links, it's 176 characters; and as raw HTML,
FOUND: it's 234 characters. In the raw HTML, there's more markup than there
FOUND: is text.
FOUND: With Markdown's reference-style links, a source document much more
FOUND: closely resembles the final output, as rendered in a browser. By
FOUND: allowing you to move the markup-related metadata out of the paragraph,
FOUND: you can add links without interrupting the narrative flow of your
FOUND: prose.
FOUND: <h3 id="em">Emphasis</h3>
FOUND: Markdown treats asterisks and underscores as indicators of
FOUND: emphasis. Text wrapped with one `*` or `_` will be wrapped with an
FOUND: HTML `<em>` tag; double `*`'s or `_`'s will be wrapped with an HTML
FOUND: `<strong>` tag. E.g., this input:
FOUND: *single asterisks*
FOUND: _single underscores_
FOUND: **double asterisks**
FOUND: __double underscores__
FOUND: will produce:
FOUND: <em>single asterisks</em>
FOUND: <em>single underscores</em>
FOUND: <strong>double asterisks</strong>
FOUND: <strong>double underscores</strong>
FOUND: You can use whichever style you prefer; the lone restriction is that
FOUND: the same character must be used to open and close an emphasis span.
FOUND: Emphasis can be used in the middle of a word:
FOUND: un*frigging*believable
FOUND: But if you surround an `*` or `_` with spaces, it'll be treated as a
FOUND: literal asterisk or underscore.
FOUND: To produce a literal asterisk or underscore at a position where it
FOUND: would otherwise be used as an emphasis delimiter, you can backslash
FOUND: escape it:
FOUND: \*this text is surrounded by literal asterisks\*
FOUND: <h3 id="code">Code</h3>
FOUND: To indicate a span of code, wrap it with backtick quotes.
FOUND: Unlike a pre-formatted code block, a code span indicates code within a
FOUND: normal paragraph. For example:
FOUND: Use the `print` function.
FOUND: will produce:
FOUND: <p>Use the <code>print</code> function.</p>
FOUND: To include a literal backtick character within a code span, you can use
FOUND: multiple backticks as the opening and closing delimiters:
FOUND: ``There is a literal backtick here.``
FOUND: which will produce this:
FOUND: <p><code>There is a literal backtick here.</code></p>
FOUND: The backtick delimiters surrounding a code span may include spaces --
FOUND: one after the opening, one before the closing. This allows you to place
FOUND: literal backtick characters at the beginning or end of a code span:
FOUND: A single backtick in a code span: `` ` ``
FOUND: A backtick-delimited string in a code span: `` `foo` ``
FOUND: will produce:
FOUND: <p>A single backtick in a code span: <code>`</code></p>
FOUND: <p>A backtick-delimited string in a code span: <code>`foo`</code></p>
FOUND: With a code span, ampersands and angle brackets are encoded as HTML
FOUND: entities automatically, which makes it easy to include example HTML
FOUND: tags. Markdown will turn this:
FOUND: Please don't use any `<blink>` tags.
FOUND: into:
FOUND: <p>Please don't use any <code>&lt;blink&gt;</code> tags.</p>
FOUND: You can write this:
FOUND: `&#8212;` is the decimal-encoded equivalent of `&mdash;`.
FOUND: to produce:
FOUND: <p><code>&amp;#8212;</code> is the decimal-encoded
FOUND: equivalent of <code>&amp;mdash;</code>.</p>
FOUND: <h3 id="img">Images</h3>
FOUND: Admittedly, it's fairly difficult to devise a "natural" syntax for
FOUND: placing images into a plain text document format.
FOUND: Markdown uses an image syntax that is intended to resemble the syntax
FOUND: for links, allowing for two styles: *inline* and *reference*.
FOUND: Inline image syntax looks like this:
FOUND: ![Alt text]
FOUND: +_*&^%$#@!!![New text]
FOUND: That is:
FOUND: *   An exclamation mark: `!`;
FOUND: *   followed by a set of square brackets, containing the `alt`
FOUND: attribute text for the image;
FOUND: *   followed by a set of parentheses, containing the URL or path to
FOUND: the image, and an optional `title` attribute enclosed in double
FOUND: or single quotes.
FOUND: Reference-style image syntax looks like this:
FOUND: !<Alt text><id>
FOUND: Where "id" is the name of a defined image reference. Image references
FOUND: are defined using syntax identical to link references:
FOUND: As of this writing, Markdown has no syntax for specifying the
FOUND: dimensions of an image; if this is important to you, you can simply
FOUND: use regular HTML `<img>` tags.
FOUND: * * *
FOUND: <h2 id="misc">Miscellaneous</h2>
FOUND: <h3 id="autolink">Automatic Links</h3>
FOUND: Markdown supports a shortcut style for creating "automatic" links for URLs and email addresses: simply surround the URL or email address with angle brackets. What this means is that if you want to show the actual text of a URL or email address, and also have it be a clickable link, you can do this:
FOUND: <http://example.com/>
FOUND: Markdown will turn this into:
FOUND: <a href="http://example.com/">http://example.com/</a>
FOUND: Automatic links for email addresses work similarly, except that
FOUND: Markdown will also perform a bit of randomized decimal and hex
FOUND: entity-encoding to help obscure your address from address-harvesting
FOUND: spambots. For example, Markdown will turn this:
FOUND: <address@example.com>
FOUND: into something like this:
FOUND: <a href="&#x6D;&#x61;i&#x6C;&#x74;&#x6F;:&#x61;&#x64;&#x64;&#x72;&#x65;
FOUND: &#115;&#115;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6C;e&#x2E;&#99;&#111;
FOUND: &#109;">&#x61;&#x64;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#101;&#120;&#x61;
FOUND: &#109;&#x70;&#x6C;e&#x2E;&#99;&#111;&#109;</a>
FOUND: which will render in a browser as a clickable link to "address@example.com".
FOUND: <h3 id="backslash">Backslash Escapes</h3>
FOUND: Markdown allows you to use backslash escapes to generate literal
FOUND: characters which would otherwise have special meaning in Markdown's
FOUND: formatting syntax. For example, if you wanted to surround a word
FOUND: with literal asterisks, you can use
FOUND: backslashes before the asterisks, like this:
FOUND: \*literal asterisks\*
FOUND: Markdown provides backslash escapes for the following characters:
FOUND: \   backslash
FOUND: `   backtick
FOUND: *   asterisk
FOUND: _   underscore
FOUND: {}  curly braces
FOUND: <>  square brackets
FOUND: parentheses
FOUND: #   hash mark
FOUND: +   plus sign
FOUND: -   minus sign
FOUND: .   dot
FOUND: !   exclamation mark

Test query18.out passed!


FOUND: 1
FOUND: data/data7.txt
FOUND: 1
FOUND: data/data6.txt
FOUND: 1
FOUND: data/data6.txt
FOUND: 1
FOUND: data/data7.txt
FOUND: 1
FOUND: data/data7.txt

Test query19.out passed!


FOUND: 2
FOUND: data/data4.txt
FOUND: data/data7.txt
FOUND: 7
FOUND: data/data1.txt
FOUND: data/data2.txt
FOUND: data/data3.txt
FOUND: data/data4.txt
FOUND: data/data5.txt
FOUND: data/data6.txt
FOUND: data/data7.txt
FOUND: 7
FOUND: data/data1.txt
FOUND: data/data2.txt
FOUND: data/data3.txt
FOUND: data/data4.txt
FOUND: data/data5.txt
FOUND: data/data6.txt
FOUND: data/data7.txt
FOUND: 2
FOUND: data/data6.txt
FOUND: data/data7.txt
FOUND: 2
FOUND: data/data6.txt
FOUND: data/data7.txt

Test query20.out passed!


All Test Cases Passed!