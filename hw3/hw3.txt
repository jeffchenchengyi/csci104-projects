Problem 2 (Runtime Analysis, 20%)
In Big-Θ notation, analyze the running time of the following pieces of code/pseudo-code. Describe the running time as a function of the input size (here, n). You should always explain your work when solving mathematics problems.

Part (a)
Stack s; //All operations on a stack take constant time.
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        s.push(j);
    }
    for (int k = n; k > i; k--) {
        s.pop();
    }
}
while (!s.empty()) {
    s.pop();
}

Answer:



Part (b)
func(0, n);

void func(int curr, int n) {
    if (n <= 0) return;
    if (curr <= 0) func(n-1, n-1);
    else func(curr-1, n);
}
Part (c)
Queue q; //all operations on a Queue take constant time.
for (int i = 1; i <= n; i++) {
    q.enqueue(i);
}

Answer:



bool swap = false;
while (!q.empty()) {
    if (swap) {
        if (q.front() == 1) {
            for (int i = n+1; i <= 2n; i++) {
                q.enqueue(i);
            }
        }
        q.dequeue();
    }
    else {
        q.enqueue(q.front());
        q.dequeue();
    }
    swap = !swap;
}

Answer:



Part (d)
struct Node {
    int value;
    Node *next;
    Node(int i) : value(i) {};
};

Node *head = NULL;
for (int i = 0; i < n; i++) {
    Node *curr = new Node(i);
    curr->next = head;
    head = curr;
}
for (int i = 1; i < n; i++) {
    Node *curr = head;
    while (curr) {
        if ((curr->value % i == 0) && (arr[i] == 0)) {
            for (int j = arr[i]; j < n; j++) {
                arr[j] *= 2;
            }
        }
        curr = curr->next;
    }
}



Problem 3 (Amortized Analysis, 20%)
Consider the following function:

void someclass::somefunc() {
    if (this->n == this->max) {
        bar();
        this->max *= 2;
    } 
    else {
        foo();
    }
    (this->n)++;
}
Assume that when someclass is created, n=0 and max=1.

Part (a)
What is the worst-case runtime for somefunc, if bar takes Θ(n^2) time and foo takes Θ(log n) time?

Answer:



Part (b)
What is the amortized runtime for somefunc, if bar takes Θ(n^2) time and foo takes Θ(log n) time?

Answer:



Part (c)
What is the amortized runtime for somefunc, if bar takes Θ(n^2) time and foo takes Θ(n log n) time?

Answer:



Part (d)
Suppose there is another function:

void someclass::anotherfunc() {
    if (this->n > 0) { 
        (this->n)--;
    }
    if (this->n < (this->max)/2) {
        bar();
        this->max /= 2;
    } 
    else {
        foo();
    }
}
Assume that bar takes Θ(n^2) time and foo takes Θ(log n) time. What is the worst-case sequence of 
calls to somefunc and anotherfunc? What would be the amortized runtime per function call?

Answer:


